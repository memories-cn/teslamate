# 模式变更模式与最佳实践

<cite>
**本文档中引用的文件**  
- [20190525125700_rename_soc_fields.exs](file://priv/repo/migrations/20190525125700_rename_soc_fields.exs)
- [20190812191616_rename_trips_to_drives.exs](file://priv/repo/migrations/20190812191616_rename_trips_to_drives.exs)
- [20190821143938_add_constraints.exs](file://priv/repo/migrations/20190821143938_add_constraints.exs)
- [20190821155748_drop_consumption_columns.exs](file://priv/repo/migrations/20190821155748_drop_consumption_columns.exs)
- [20191026144449_drop_cp_confidence_and_interval.exs](file://priv/repo/migrations/20191026144449_drop_cp_confidence_and_interval.exs)
- [20200320140020_drop_power_avg.exs](file://priv/repo/migrations/20200320140020_drop_power_avg.exs)
- [20200401170940_remove_sleep_mode_toggles.exs](file://priv/repo/migrations/20200401170940_remove_sleep_mode_toggles.exs)
- [20200401171402_remove_sleep_mode_requirements.exs](file://priv/repo/migrations/20200401171402_remove_sleep_mode_requirements.exs)
- [20190416125429_add_indexes_on_dates.exs](file://priv/repo/migrations/20190416125429_add_indexes_on_dates.exs)
- [20190717184003_add_fkey_indexes.exs](file://priv/repo/migrations/20190717184003_add_fkey_indexes.exs)
- [20191007105010_add_new_fkey_indexes.exs](file://priv/repo/migrations/20191007105010_add_new_fkey_indexes.exs)
- [20200502140646_drop_unused_indexes.exs](file://priv/repo/migrations/20200502140646_drop_unused_indexes.exs)
- [20190729142656_add_conversion_functions.exs](file://priv/repo/migrations/20190729142656_add_conversion_functions.exs)
- [20190810105216_unit_of_length_and_temperature.exs](file://priv/repo/migrations/20190810105216_unit_of_length_and_temperature.exs)
- [20200410112005_database_efficiency_improvements.exs](file://priv/repo/migrations/20200410112005_database_efficiency_improvements.exs)
- [20220123131732_encrypt_api_tokens.exs](file://priv/repo/migrations/20220123131732_encrypt_api_tokens.exs)
- [20240915193446_composite_index_with_predicate_to_position.exs](file://priv/repo/migrations/20240915193446_composite_index_with_predicate_to_position.exs)
</cite>

## 目录
1. [引言](#引言)
2. [字段重命名模式](#字段重命名模式)
3. [表重命名策略](#表重命名策略)
4. [类型调整与数据优化](#类型调整与数据优化)
5. [索引优化实践](#索引优化实践)
6. [约束变更与数据完整性](#约束变更与数据完整性)
7. [破坏性变更的安全处理流程](#破坏性变更的安全处理流程)
8. [高可用系统中的模式演进最佳实践](#高可用系统中的模式演进最佳实践)
9. [总结](#总结)

## 引言
TeslaMate 是一个用于跟踪和分析特斯拉车辆数据的开源系统，其数据库模式随着功能演进而持续变化。本文系统性地归纳了该项目中常见的数据库模式变更模式，包括字段重命名、表重命名、类型调整、索引优化和约束变更。通过分析实际迁移文件，总结出在高可用系统中进行安全模式演进的最佳实践。

**目录**
- [字段重命名模式](#字段重命名模式)
- [表重命名策略](#表重命名策略)
- [类型调整与数据优化](#类型调整与数据优化)
- [索引优化实践](#索引优化实践)
- [约束变更与数据完整性](#约束变更与数据完整性)
- [破坏性变更的安全处理流程](#破坏性变更的安全处理流程)
- [高可用系统中的模式演进最佳实践](#高可用系统中的模式演进最佳实践)

## 字段重命名模式
在 TeslaMate 中，字段重命名通常使用 Ecto 的 `rename` 函数实现，确保数据平滑迁移。例如，在 `20190525125700_rename_soc_fields.exs` 迁移中，将充电过程表中的 `start_soc` 和 `end_soc` 字段重命名为更具语义的 `start_range_km` 和 `end_range_km`，以更准确地反映其表示的是续航里程而非电池百分比。

此类变更属于非破坏性变更，不会丢失数据，但需要确保应用程序代码同步更新以引用新字段名。迁移文件简洁明了，仅包含重命名操作，降低了出错风险。

**Section sources**
- [20190525125700_rename_soc_fields.exs](file://priv/repo/migrations/20190525125700_rename_soc_fields.exs#L5-L6)

## 表重命名策略
表重命名比字段重命名更为复杂，因为它涉及到外键约束、索引以及所有引用该表的查询。在 `20190812191616_rename_trips_to_drives.exs` 迁移中，项目将 `trips` 表重命名为 `drives`，以更符合特斯拉车辆数据的语义。

该迁移不仅重命名了主表，还更新了 `positions` 表中指向它的外键字段（从 `trip_id` 到 `drive_id`），并手动执行 SQL 命令来重命名相关的数据库索引和外键约束。这体现了在进行大规模重构时，除了使用 Ecto 提供的高级 API 外，有时还需要直接执行原生 SQL 来处理框架无法自动管理的数据库对象。

**Section sources**
- [20190812191616_rename_trips_to_drives.exs](file://priv/repo/migrations/20190812191616_rename_trips_to_drives.exs#L5-L7)

## 类型调整与数据优化
类型调整是优化数据库性能和存储效率的关键手段。`20200410112005_database_efficiency_improvements.exs` 迁移是一个典型的例子，它对多个表的字段类型进行了精细化调整。

例如，将 `cars` 表的主键从默认的 `:integer` 修改为 `:smallint`，因为车辆数量通常不会超过 32,767。同时，对地理位置相关的字段（如经纬度）使用 `:numeric` 类型并指定精度（`precision: 8, scale: 6`），以平衡存储空间和精度需求。此外，将 `battery_level` 等百分比值从 `:integer` 修改为 `:smallint`，因为其取值范围为 0-100，`smallint` 足够且更节省空间。

这种精细化的类型管理显著减少了数据库的存储占用，并可能提升查询性能。

**Section sources**
- [20200410112005_database_efficiency_improvements.exs](file://priv/repo/migrations/20200410112005_database_efficiency_improvements.exs#L5-L112)

## 索引优化实践
索引是提升数据库查询性能的核心。TeslaMate 的迁移历史展示了从简单索引到复杂索引的演进过程。

早期的 `20190416125429_add_indexes_on_dates.exs` 迁移为 `positions` 和 `charges` 表的 `date` 字段添加了基础索引，以加速按日期查询。随后的 `20190717184003_add_fkey_indexes.exs` 为所有外键字段（如 `car_id`, `charging_process_id`）添加索引，这是优化 JOIN 操作的标准做法。

更高级的优化体现在 `20191007105010_add_new_fkey_indexes.exs` 中，它将地理位置查询的索引从普通 B-Tree 改为使用 `gist` 的空间索引，极大提升了基于地理位置的查询效率。而 `20240915193446_composite_index_with_predicate_to_position.exs` 则创建了带条件的复合索引，进一步优化了特定查询模式的性能。

同时，项目也注重清理，`20200502140646_drop_unused_indexes.exs` 迁移删除了不再使用的索引，避免了不必要的写入开销和存储浪费。

**Section sources**
- [20190416125429_add_indexes_on_dates.exs](file://priv/repo/migrations/20190416125429_add_indexes_on_dates.exs#L5-L6)
- [20190717184003_add_fkey_indexes.exs](file://priv/repo/migrations/20190717184003_add_fkey_indexes.exs#L5-L21)
- [20191007105010_add_new_fkey_indexes.exs](file://priv/repo/migrations/20191007105010_add_new_fkey_indexes.exs#L14-L16)
- [20200502140646_drop_unused_indexes.exs](file://priv/repo/migrations/20200502140646_drop_unused_indexes.exs#L5-L6)
- [20240915193446_composite_index_with_predicate_to_position.exs](file://priv/repo/migrations/20240915193446_composite_index_with_predicate_to_position.exs)

## 约束变更与数据完整性
添加数据库约束是保障数据质量的重要手段。`20190821143938_add_constraints.exs` 迁移为 `states` 表添加了两个关键约束：一是创建唯一索引，确保每辆车在同一时刻只有一个“进行中”（`end_date IS NULL`）的状态记录；二是添加检查约束，确保 `end_date` 不会早于 `start_date`。

这些约束在数据库层面强制执行了业务规则，防止了应用层可能出现的逻辑错误导致的数据不一致。与在应用层进行验证相比，数据库约束提供了更强的一致性保证。

**Section sources**
- [20190821143938_add_constraints.exs](file://priv/repo/migrations/20190821143938_add_constraints.exs#L5-L7)

## 破坏性变更的安全处理流程
破坏性变更，如字段删除或类型更改，必须极其谨慎地处理。TeslaMate 的迁移文件展示了成熟的安全处理流程。

对于字段删除，如 `20190821155748_drop_consumption_columns.exs` 和 `20200320140020_drop_power_avg.exs`，迁移直接使用 `remove` 指令。虽然这些操作不可逆，但项目通过版本控制和备份策略来管理风险。

最复杂的破坏性变更是 `20220123131732_encrypt_api_tokens.exs`，它将明文存储的 API 令牌加密。该迁移采用了“双写”和“分阶段”策略：
1.  **添加新字段**：首先添加 `encrypted_refresh` 和 `encrypted_access` 两个二进制字段。
2.  **数据迁移**：读取所有现有令牌，使用加密库（Cloak）将明文数据加密后写入新字段。
3.  **切换与清理**：确认数据迁移成功后，删除旧的明文字段，并将加密字段重命名为 `refresh` 和 `access`。

此流程确保了在迁移过程中服务不中断，且数据始终处于可用状态。迁移脚本还包含了生成加密密钥、提示用户设置环境变量等逻辑，体现了对生产环境安全性的周全考虑。

**Section sources**
- [20190821155748_drop_consumption_columns.exs](file://priv/repo/migrations/20190821155748_drop_consumption_columns.exs#L6-L7)
- [20200320140020_drop_power_avg.exs](file://priv/repo/migrations/20200320140020_drop_power_avg.exs#L6)
- [20220123131732_encrypt_api_tokens.exs](file://priv/repo/migrations/20220123131732_encrypt_api_tokens.exs#L73-L122)

## 高可用系统中的模式演进最佳实践
基于 TeslaMate 的实践，可以总结出在高可用系统中进行数据库模式演进的最佳实践：

1.  **分阶段部署**：对于复杂的变更（如加密），采用“添加-迁移-切换-删除”的四步法，避免一次性大改动。
2.  **向后兼容性**：在删除旧字段或表之前，确保所有依赖它们的应用代码都已更新并部署。使用双写机制可以实现平滑过渡。
3.  **数据备份**：在执行任何破坏性变更前，必须进行完整的数据库备份。
4.  **灰度验证**：在生产环境中，先在小范围用户或非关键服务上应用变更，验证无误后再全面推广。
5.  **监控指标观察**：变更后，密切监控数据库性能指标（如查询延迟、CPU 使用率、锁等待时间）和应用错误日志，及时发现潜在问题。
6.  **幂等性与可逆性**：编写幂等的迁移脚本，并尽可能提供 `down` 函数，以便在出现问题时能够回滚。
7.  **清晰的文档与提示**：像 `encrypt_api_tokens` 迁移那样，在关键步骤输出清晰的日志和操作指引，帮助用户正确配置环境。

这些实践共同构成了一个安全、可靠的数据库演进流程，最大限度地降低了对系统可用性的影响。

## 总结
TeslaMate 的数据库迁移历史是一个学习数据库模式演进的优秀案例。它展示了从简单的字段重命名到复杂的加密升级等各种变更模式。核心原则是：**小步迭代、安全优先、自动化与监控并重**。通过采用分阶段部署、双写机制和严格的测试验证，即使是破坏性变更也能在高可用系统中安全地执行。这些经验对于任何需要持续演进的生产级应用都具有重要的参考价值。