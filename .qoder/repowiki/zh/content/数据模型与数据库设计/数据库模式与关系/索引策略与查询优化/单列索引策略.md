# 单列索引策略

<cite>
**本文档引用的文件**  
- [20190416125429_add_indexes_on_dates.exs](file://priv/repo/migrations/20190416125429_add_indexes_on_dates.exs)
- [20190717184003_add_fkey_indexes.exs](file://priv/repo/migrations/20190717184003_add_fkey_indexes.exs)
- [20230417225712_composite_index_to_position.exs](file://priv/repo/migrations/20230417225712_composite_index_to_position.exs)
- [20240915193446_composite_index_with_predicate_to_position.exs](file://priv/repo/migrations/20240915193446_composite_index_with_predicate_to_position.exs)
- [log.ex](file://lib/teslamate/log.ex)
- [position.ex](file://lib/teslamate/log/position.ex)
- [database-info.json](file://grafana/dashboards/database-info.json)
- [development.mdx](file://website/docs/development.mdx)
</cite>

## 目录
1. [引言](#引言)
2. [单列索引设计决策](#单列索引设计决策)
3. [复合索引演进](#复合索引演进)
4. [查询性能分析](#查询性能分析)
5. [EXPLAIN ANALYZE 使用方法](#explain-analyze-使用方法)
6. [索引监控与优化](#索引监控与优化)
7. [结论](#结论)

## 引言
TeslaMate 是一个用于跟踪特斯拉车辆数据的应用程序，其核心功能依赖于对大量位置、驾驶和充电记录的高效查询。随着数据量的增长，数据库查询性能成为系统稳定性的关键因素。本文件详细说明在数据库表中对单个字段（如 car_id、date、drive_id）创建索引的设计决策，解释这些索引如何加速基于时间范围或车辆ID的查询，并结合Ecto迁移文件中的实际代码示例展示索引创建语法。

## 单列索引设计决策
在 TeslaMate 的早期版本中，开发团队通过添加单列索引来优化高频查询的性能。这些索引主要针对外键和时间戳字段，以支持常见的数据检索场景。

例如，在 `20190717184003_add_fkey_indexes.exs` 迁移文件中，为多个表的关键字段创建了单列索引：

```elixir
create(index(:positions, [:car_id]))
create(index(:positions, [:trip_id]))
create(index(:charges, [:charging_process_id]))
```

这些索引的设计基于以下查询模式：
- 基于车辆ID（car_id）检索特定车辆的所有位置记录
- 基于行程ID（trip_id）获取某次行程的所有位置点
- 通过充电过程ID（charging_process_id）关联充电记录

此外，在 `20190416125429_add_indexes_on_dates.exs` 中为日期字段创建索引：

```elixir
create(index(:positions, [:date]))
create(index(:charges, [:date]))
```

这一决策显著提升了基于时间范围的查询效率，例如“检索某一天内所有车辆的位置记录”或“查询某月的充电事件”。

**Section sources**
- [20190416125429_add_indexes_on_dates.exs](file://priv/repo/migrations/20190416125429_add_indexes_on_dates.exs#L5-L7)
- [20190717184003_add_fkey_indexes.exs](file://priv/repo/migrations/20190717184003_add_fkey_indexes.exs#L11-L12)

## 复合索引演进
随着查询复杂度的增加，单列索引逐渐无法满足性能需求。开发团队引入了复合索引（Composite Index）来进一步优化查询计划。

在 `20230417225712_composite_index_to_position.exs` 中，将原有的 `drive_id` 单列索引升级为复合索引：

```elixir
create index(:positions, [:drive_id, :date])
drop index(:positions, [:drive_id])
```

该复合索引特别适用于“检索某次驾驶过程中按时间排序的所有位置点”的查询场景，避免了额外的排序操作。

更进一步，在 `20240915193446_composite_index_with_predicate_to_position.exs` 中引入了带条件的复合索引（Partial Index）：

```elixir
create index(:positions, [:car_id, :date, "(ideal_battery_range_km IS NOT NULL)"],
         where: "ideal_battery_range_km IS NOT NULL"
       )
```

此索引仅包含 `ideal_battery_range_km` 非空的记录，专门用于优化非流式数据的查询性能。根据文档说明，流式API产生的数据占总数据量的95%以上，而此索引可有效过滤掉高频但低价值的流式记录，提升关键业务查询的效率。

**Section sources**
- [20230417225712_composite_index_to_position.exs](file://priv/repo/migrations/20230417225712_composite_index_to_position.exs#L5-L7)
- [20240915193446_composite_index_with_predicate_to_position.exs](file://priv/repo/migrations/20240915193446_composite_index_with_predicate_to_position.exs#L5-L7)

## 查询性能分析
TeslaMate 中的许多核心功能依赖于高效的数据库查询。以下是一些典型查询及其索引使用情况的分析。

### 最新位置查询
获取某辆车的最新位置是高频操作，其实现如下：

```elixir
def get_latest_position(%Car{id: id}) do
  Position
  |> where(car_id: ^id)
  |> order_by(desc: :date)
  |> limit(1)
  |> Repo.one()
end
```

该查询依赖于 `(car_id, date)` 的复合索引（或单列索引组合），能够快速定位并排序结果，避免全表扫描。

### 无高程数据的位置查询
系统需要定期为缺失高程信息的位置补全数据，相关查询如下：

```elixir
Position
|> where([p], p.id > ^min_id and is_nil(p.elevation) and p.drive_id in ^non_streamed_drives and p.date > ^naive_date_earliest)
|> order_by(asc: :id)
|> limit(^limit)
|> Repo.all()
```

该查询涉及多个过滤条件，复合索引 `(drive_id, date)` 显著提升了执行效率。

**Section sources**
- [log.ex](file://lib/teslamate/log.ex#L165-L171)
- [log.ex](file://lib/teslamate/log.ex#L211-L215)

## EXPLAIN ANALYZE 使用方法
为了评估查询执行计划并识别性能瓶颈，TeslaMate 推荐使用 PostgreSQL 的 `EXPLAIN ANALYZE` 命令。

### 基本语法
```sql
EXPLAIN ANALYZE SELECT * FROM positions WHERE car_id = 1 AND date >= '2024-01-01';
```

输出将显示：
- 是否使用了索引（Index Scan）
- 预估行数 vs 实际行数
- 执行时间（Execution Time）
- 是否发生全表扫描（Seq Scan）

### 识别全表扫描问题
当查询计划中出现 `Seq Scan` 且过滤条件未命中索引时，表明存在性能隐患。例如：

```
Seq Scan on positions  (cost=0.00..10000.00 rows=1000 width=200)
  Filter: (car_id = 1)
```

此时应检查是否缺少 `(car_id)` 或 `(car_id, date)` 索引，并通过迁移文件添加。

**Section sources**
- [development.mdx](file://website/docs/development.mdx#L175-L202)

## 索引监控与优化
TeslaMate 提供了 Grafana 仪表板来监控数据库性能，其中 `database-info.json` 包含关键的索引使用统计：

```sql
SELECT relname AS "Table", indexrelname AS "Index", idx_scan AS "Index Scans", idx_tup_read AS "Tuples Read"
FROM pg_stat_all_indexes
ORDER BY idx_scan DESC;
```

该查询可识别：
- 高频使用的索引（高 `idx_scan` 值）
- 从未被使用的索引（`idx_scan = 0`），可考虑删除以节省空间
- 热点表和索引，指导进一步优化

此外，通过启用 `pg_stat_statements` 扩展，可以收集所有 SQL 语句的执行统计：

```sql
CREATE EXTENSION IF NOT EXISTS pg_stat_statements;
SELECT query, calls, mean_exec_time, total_exec_time FROM pg_stat_statements ORDER BY mean_exec_time DESC LIMIT 10;
```

**Section sources**
- [database-info.json](file://grafana/dashboards/database-info.json#L875-L883)
- [development.mdx](file://website/docs/development.mdx#L194-L196)

## 结论
TeslaMate 的索引策略经历了从单列索引到复合索引，再到带条件的复合索引的演进过程。这一演进反映了系统从基础查询支持到高性能、高选择性查询优化的技术发展路径。通过合理设计索引结构，系统能够在海量数据下保持高效的查询响应能力。建议在开发新功能时始终使用 `EXPLAIN ANALYZE` 验证查询计划，确保索引的有效利用，避免全表扫描带来的性能退化。